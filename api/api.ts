/* tslint:disable */
/* eslint-disable */
/**
 * Rest API for HOA APP
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Access
 */
export interface Access {
    /**
     * 
     * @type {number}
     * @memberof Access
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Access
     */
    create?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Access
     */
    read?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Access
     */
    update?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Access
     */
    _delete?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Access
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Access
     */
    role?: number;
    /**
     * 
     * @type {number}
     * @memberof Access
     */
    screen?: number;
    /**
     * 
     * @type {Role}
     * @memberof Access
     */
    roleData?: Role;
    /**
     * 
     * @type {Screen}
     * @memberof Access
     */
    screenData?: Screen;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Access
     */
    updatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof Access
     */
    lastModifiedBy?: number;
    /**
     * 
     * @type {User}
     * @memberof Access
     */
    lastModifiedUser?: User;
}
/**
 * 
 * @export
 * @interface Bookmark
 */
export interface Bookmark {
    /**
     * 
     * @type {number}
     * @memberof Bookmark
     */
    lprLopgId?: number;
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    frame_64?: string;
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    plate_64?: string;
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    numplate_text?: string;
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    numplate_polygon?: string;
    /**
     * 
     * @type {number}
     * @memberof Bookmark
     */
    aggregated_confidence?: number;
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    make?: string;
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    model?: string;
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    year?: string;
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Bookmark
     */
    capturedAt?: string;
    /**
     * 
     * @type {Device}
     * @memberof Bookmark
     */
    device?: Device;
}
/**
 * 
 * @export
 * @interface CustomerAccount
 */
export interface CustomerAccount {
    /**
     * 
     * @type {number}
     * @memberof CustomerAccount
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomerAccount
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerAccount
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerAccount
     */
    address?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomerAccount
     */
    phone?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomerAccount
     */
    billingName?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerAccount
     */
    billingAddress?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerAccount
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomerAccount
     */
    customerType?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerAccount
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerAccount
     */
    updatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomerAccount
     */
    lastModifiedBy?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomerAccount
     */
    lastModifiedByUser?: string;
}
/**
 * 
 * @export
 * @interface CustomerCard
 */
export interface CustomerCard {
    /**
     * 
     * @type {number}
     * @memberof CustomerCard
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomerCard
     */
    last4Digits?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomerCard
     */
    cardType?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCard
     */
    stripeToken?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerCard
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CustomerCard
     */
    customerAccountId?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomerCard
     */
    cardId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerCard
     */
    isDefault?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomerCard
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCard
     */
    updatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomerCard
     */
    lastModifiedBy?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomerCard
     */
    expMonth?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomerCard
     */
    expYear?: number;
}
/**
 * 
 * @export
 * @interface CustomerPlan
 */
export interface CustomerPlan {
    /**
     * 
     * @type {number}
     * @memberof CustomerPlan
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomerPlan
     */
    purchaseDate?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerPlan
     */
    expiryDate?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomerPlan
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CustomerPlan
     */
    customerAccountId?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomerPlan
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerPlan
     */
    updatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof CustomerPlan
     */
    lastModifiedBy?: number;
    /**
     * 
     * @type {Plan}
     * @memberof CustomerPlan
     */
    plan?: Plan;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    hostnameOrIp?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    rtspUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    port?: number;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    deviceUserId?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    devicePassword?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    tag?: string;
    /**
     * 
     * @type {Location}
     * @memberof Device
     */
    location?: Location;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    make?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    model?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Device
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    propertyId?: number;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    customerAccountId?: number;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    customerPlanId?: number;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    updatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    lastModifiedBy?: number;
    /**
     * 
     * @type {User}
     * @memberof Device
     */
    lastModifiedUser?: User;
    /**
     * 
     * @type {Property}
     * @memberof Device
     */
    property?: Property;
    /**
     * 
     * @type {CustomerPlan}
     * @memberof Device
     */
    customerPlan?: CustomerPlan;
}
/**
 * 
 * @export
 * @interface LastScan
 */
export interface LastScan {
    /**
     * 
     * @type {number}
     * @memberof LastScan
     */
    deviceId?: number;
    /**
     * 
     * @type {string}
     * @memberof LastScan
     */
    updatedBy?: string;
}
/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    lat?: number;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    _long?: number;
}
/**
 * 
 * @export
 * @interface LprLogs
 */
export interface LprLogs {
    /**
     * 
     * @type {number}
     * @memberof LprLogs
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof LprLogs
     */
    deviceId?: string;
    /**
     * 
     * @type {object}
     * @memberof LprLogs
     */
    lprJson?: object;
    /**
     * 
     * @type {string}
     * @memberof LprLogs
     */
    fram_path?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogs
     */
    duplicate_frame_path?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogs
     */
    plate_path?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogs
     */
    image64?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogs
     */
    frame64?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogs
     */
    numplate_text?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogs
     */
    numplate_polygon?: string;
    /**
     * 
     * @type {number}
     * @memberof LprLogs
     */
    aggregated_confidence?: number;
    /**
     * 
     * @type {string}
     * @memberof LprLogs
     */
    make?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogs
     */
    model?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogs
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogs
     */
    year?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogs
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogs
     */
    capturedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogs
     */
    expiryDate?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LprLogs
     */
    expired?: boolean;
    /**
     * 
     * @type {Device}
     * @memberof LprLogs
     */
    device?: Device;
}
/**
 * 
 * @export
 * @interface LprLogsPage
 */
export interface LprLogsPage {
    /**
     * 
     * @type {number}
     * @memberof LprLogsPage
     */
    currentPage?: number;
    /**
     * 
     * @type {number}
     * @memberof LprLogsPage
     */
    totalPages?: number;
    /**
     * 
     * @type {number}
     * @memberof LprLogsPage
     */
    totalItems?: number;
    /**
     * 
     * @type {Array<LprLogs>}
     * @memberof LprLogsPage
     */
    items?: Array<LprLogs>;
}
/**
 * 
 * @export
 * @interface LprLogsSearch
 */
export interface LprLogsSearch {
    /**
     * 
     * @type {string}
     * @memberof LprLogsSearch
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogsSearch
     */
    numplate_text?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogsSearch
     */
    make?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogsSearch
     */
    model?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogsSearch
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogsSearch
     */
    year?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogsSearch
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof LprLogsSearch
     */
    endTime?: string;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    numplate?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    make?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    model?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    color?: string;
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    propertyId?: number;
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    customerAccountId?: number;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    updatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    lastModifiedBy?: number;
    /**
     * 
     * @type {User}
     * @memberof Notification
     */
    lastModifiedUser?: User;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    paymentStatus?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    paymentMode?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    cardId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    planId?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    total?: number;
    /**
     * 
     * @type {object}
     * @memberof Order
     */
    charge?: object;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    remarks?: string;
    /**
     * 
     * @type {CustomerAccount}
     * @memberof Order
     */
    customerAccountInstance?: CustomerAccount;
    /**
     * 
     * @type {Plan}
     * @memberof Order
     */
    plan?: Plan;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    customerAccountId?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface PatrolRules
 */
export interface PatrolRules {
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    unauthorized?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    expiredStickers?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatrolRules
     */
    expiredStickersDelay?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    parkedOnGrass?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    blockingDumpster?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    alteredPass?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    publicSafetyThreat?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    expiredRegistration?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    flatTires?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    expiredPasses?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    expiredPassesDelay?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    fireLane?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    noParkingZone?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    doubleParked?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    blockingDrive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    abondonedVehicle?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    visitorInResident?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    residentInVisitor?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    parkedInHandicap?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatrolRules
     */
    headInParkingOnly?: boolean;
}
/**
 * 
 * @export
 * @interface Permit
 */
export interface Permit {
    /**
     * 
     * @type {number}
     * @memberof Permit
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Permit
     */
    plateNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof Permit
     */
    make?: string;
    /**
     * 
     * @type {string}
     * @memberof Permit
     */
    model?: string;
    /**
     * 
     * @type {string}
     * @memberof Permit
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof Permit
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof Permit
     */
    source?: string;
    /**
     * 
     * @type {string}
     * @memberof Permit
     */
    expiresOn?: string;
    /**
     * 
     * @type {number}
     * @memberof Permit
     */
    tenantId?: number;
    /**
     * 
     * @type {number}
     * @memberof Permit
     */
    userId?: number;
    /**
     * 
     * @type {number}
     * @memberof Permit
     */
    permitTypeId?: number;
    /**
     * 
     * @type {number}
     * @memberof Permit
     */
    propertyId?: number;
    /**
     * 
     * @type {Tenant}
     * @memberof Permit
     */
    tenant?: Tenant;
    /**
     * 
     * @type {User}
     * @memberof Permit
     */
    user?: User;
    /**
     * 
     * @type {Property}
     * @memberof Permit
     */
    property?: Property;
    /**
     * 
     * @type {PermitType}
     * @memberof Permit
     */
    permitType?: PermitType;
    /**
     * 
     * @type {string}
     * @memberof Permit
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Permit
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface PermitPage
 */
export interface PermitPage {
    /**
     * 
     * @type {number}
     * @memberof PermitPage
     */
    currentPage?: number;
    /**
     * 
     * @type {number}
     * @memberof PermitPage
     */
    totalPages?: number;
    /**
     * 
     * @type {number}
     * @memberof PermitPage
     */
    totalItems?: number;
    /**
     * 
     * @type {Array<Permit>}
     * @memberof PermitPage
     */
    items?: Array<Permit>;
}
/**
 * 
 * @export
 * @interface PermitType
 */
export interface PermitType {
    /**
     * 
     * @type {number}
     * @memberof PermitType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PermitType
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PermitType
     */
    lastModifiedBy?: number;
    /**
     * 
     * @type {User}
     * @memberof PermitType
     */
    lastModifiedUser?: User;
}
/**
 * 
 * @export
 * @interface Plan
 */
export interface Plan {
    /**
     * 
     * @type {number}
     * @memberof Plan
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    caption?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof Plan
     */
    tenureInDays?: number;
    /**
     * 
     * @type {number}
     * @memberof Plan
     */
    retentionInDays?: number;
    /**
     * 
     * @type {number}
     * @memberof Plan
     */
    deviceCount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Plan
     */
    isTrailPlan?: boolean;
    /**
     * 
     * @type {object}
     * @memberof Plan
     */
    settings?: object;
    /**
     * 
     * @type {number}
     * @memberof Plan
     */
    cost?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Plan
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    updatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof Plan
     */
    lastModifiedBy?: number;
    /**
     * 
     * @type {User}
     * @memberof Plan
     */
    lastModifiedUser?: User;
}
/**
 * 
 * @export
 * @interface ProcessHeartBeat
 */
export interface ProcessHeartBeat {
    /**
     * 
     * @type {string}
     * @memberof ProcessHeartBeat
     */
    processName?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessHeartBeat
     */
    updatedBy?: string;
}
/**
 * 
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * 
     * @type {number}
     * @memberof Property
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    address?: string;
    /**
     * 
     * @type {Location}
     * @memberof Property
     */
    location?: Location;
    /**
     * 
     * @type {boolean}
     * @memberof Property
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    propertyCode?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    gateCode?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    gateCodeWord?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    zipCode?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    vsf?: string;
    /**
     * 
     * @type {number}
     * @memberof Property
     */
    towFee?: number;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    managerName?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    managerPhone?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    managerEmail?: string;
    /**
     * 
     * @type {PropertyConfiguration}
     * @memberof Property
     */
    propertyConfiguration?: PropertyConfiguration;
    /**
     * 
     * @type {number}
     * @memberof Property
     */
    customerAccountId?: number;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    updatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof Property
     */
    lastModifiedBy?: number;
}
/**
 * 
 * @export
 * @interface PropertyConfiguration
 */
export interface PropertyConfiguration {
    /**
     * 
     * @type {number}
     * @memberof PropertyConfiguration
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyConfiguration
     */
    patrolHourStart?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyConfiguration
     */
    patrolHourEnd?: number;
    /**
     * 
     * @type {PatrolRules}
     * @memberof PropertyConfiguration
     */
    patrolRules?: PatrolRules;
    /**
     * 
     * @type {boolean}
     * @memberof PropertyConfiguration
     */
    tenantVisitorPermits?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PropertyConfiguration
     */
    defaultPassTime?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyConfiguration
     */
    maxPermit7days?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyConfiguration
     */
    maxPermit28days?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyConfiguration
     */
    maxAllowedVisitorPermits?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyConfiguration
     */
    maxAllowedVisitorPerTenant?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyConfiguration
     */
    resetGraceTime?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyConfiguration
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyConfiguration
     */
    updatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof PropertyConfiguration
     */
    lastModifiedBy?: number;
}
/**
 * 
 * @export
 * @interface ProviderSignIn
 */
export interface ProviderSignIn {
    /**
     * 
     * @type {string}
     * @memberof ProviderSignIn
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderSignIn
     */
    idToken?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderSignIn
     */
    accessToken?: string;
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Role
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    updatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    lastModifiedBy?: number;
    /**
     * 
     * @type {User}
     * @memberof Role
     */
    lastModifiedUser?: User;
}
/**
 * 
 * @export
 * @interface Screen
 */
export interface Screen {
    /**
     * 
     * @type {number}
     * @memberof Screen
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Screen
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Screen
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Screen
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Screen
     */
    updatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof Screen
     */
    lastModifiedBy?: number;
    /**
     * 
     * @type {User}
     * @memberof Screen
     */
    lastModifiedUser?: User;
}
/**
 * 
 * @export
 * @interface Tenant
 */
export interface Tenant {
    /**
     * 
     * @type {number}
     * @memberof Tenant
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    appId?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    secondary?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Tenant
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    updatedAt?: string;
    /**
     * 
     * @type {number}
     * @memberof Tenant
     */
    propertyId?: number;
    /**
     * 
     * @type {number}
     * @memberof Tenant
     */
    userId?: number;
    /**
     * 
     * @type {Property}
     * @memberof Tenant
     */
    property?: Property;
    /**
     * 
     * @type {User}
     * @memberof Tenant
     */
    user?: User;
}
/**
 * 
 * @export
 * @interface TenantPage
 */
export interface TenantPage {
    /**
     * 
     * @type {number}
     * @memberof TenantPage
     */
    currentPage?: number;
    /**
     * 
     * @type {number}
     * @memberof TenantPage
     */
    totalPages?: number;
    /**
     * 
     * @type {number}
     * @memberof TenantPage
     */
    totalItems?: number;
    /**
     * 
     * @type {Array<Tenant>}
     * @memberof TenantPage
     */
    items?: Array<Tenant>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstname?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    phone?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    accessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    provider?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    resetPasswordToken?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    confirmToken?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    active?: boolean;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    customerAccountId?: number;
    /**
     * 
     * @type {CustomerAccount}
     * @memberof User
     */
    CustomerAccount?: CustomerAccount;
}
/**
 * 
 * @export
 * @interface UserLoginRequest
 */
export interface UserLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof UserLoginRequest
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginRequest
     */
    password: string;
}
/**
 * 
 * @export
 * @interface UserLoginSuccess
 */
export interface UserLoginSuccess {
    /**
     * 
     * @type {string}
     * @memberof UserLoginSuccess
     */
    accessToken?: string;
    /**
     * 
     * @type {User}
     * @memberof UserLoginSuccess
     */
    user?: User;
}
/**
 * 
 * @export
 * @interface UserRegister
 */
export interface UserRegister {
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    email?: string;
    /**
     * 
     * @type {number}
     * @memberof UserRegister
     */
    phone?: number;
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    provider?: string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Access} access 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccess: async (access: Access, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'access' is not null or undefined
            assertParamExists('createAccess', 'access', access)
            const localVarPath = `/access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(access, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Order} order 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderAdmin: async (order: Order, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('createOrderAdmin', 'order', order)
            const localVarPath = `/order/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(order, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Plan} plan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlan: async (plan: Plan, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'plan' is not null or undefined
            assertParamExists('createPlan', 'plan', plan)
            const localVarPath = `/plan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(plan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Role} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole: async (role: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            assertParamExists('createRole', 'role', role)
            const localVarPath = `/role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Screen} screen 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScreen: async (screen: Screen, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'screen' is not null or undefined
            assertParamExists('createScreen', 'screen', screen)
            const localVarPath = `/screen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(screen, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserForAdmin: async (user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createUserForAdmin', 'user', user)
            const localVarPath = `/user/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccess: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAccess', 'id', id)
            const localVarPath = `/access/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerAccount: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCustomerAccount', 'id', id)
            const localVarPath = `/customerAccount/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceForAdmin: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDeviceForAdmin', 'id', id)
            const localVarPath = `/device/admin/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrder', 'id', id)
            const localVarPath = `/order/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlan: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePlan', 'id', id)
            const localVarPath = `/plan/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRole', 'id', id)
            const localVarPath = `/role/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScreen: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteScreen', 'id', id)
            const localVarPath = `/screen/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteUser', 'id', id)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllAccesses: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/access`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllCustomerAccount: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/customerAccount/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [propertyId] Unique identifier for a property
         * @param {string} [customerAccountId] For identifying customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDeviceForAdmin: async (propertyId?: string, customerAccountId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/device/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (propertyId !== undefined) {
                localVarQueryParameter['propertyId'] = propertyId;
            }

            if (customerAccountId !== undefined) {
                localVarQueryParameter['customerAccountId'] = customerAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllLastScans: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/lastScan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {Array} [deviceId] Unique identifier for a device
         * @param {string} [propertyId] Unique identifier for a property
         * @param {string} [customerAccountId] For identifying customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllLprLogsForAdmin: async (size: number, page: number, deviceId?: Array, propertyId?: string, customerAccountId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'size' is not null or undefined
            assertParamExists('findAllLprLogsForAdmin', 'size', size)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('findAllLprLogsForAdmin', 'page', page)
            const localVarPath = `/lprLogs/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (propertyId !== undefined) {
                localVarQueryParameter['propertyId'] = propertyId;
            }

            if (customerAccountId !== undefined) {
                localVarQueryParameter['customerAccountId'] = customerAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllOrdersForAdmin: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllPlanForAdmin: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/plan/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [customerAccountId] For identifying customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllPropertyForAdmin: async (customerAccountId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/property/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (customerAccountId !== undefined) {
                localVarQueryParameter['customerAccountId'] = customerAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllRoles: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllScreens: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/screen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllUsersForAdmin: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneAccess: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOneAccess', 'id', id)
            const localVarPath = `/access/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {string} [customerAccountId] For identifying customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneLprLogForAdmin: async (id: string, customerAccountId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOneLprLogForAdmin', 'id', id)
            const localVarPath = `/lprLogs/admin/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (customerAccountId !== undefined) {
                localVarQueryParameter['customerAccountId'] = customerAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneProcessHeartBeat: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOneProcessHeartBeat', 'id', id)
            const localVarPath = `/processHeartBeat/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneRole: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOneRole', 'id', id)
            const localVarPath = `/role/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneScreen: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOneScreen', 'id', id)
            const localVarPath = `/screen/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneUser: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOneUser', 'id', id)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProcessHeartBeat: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/processHeartBeat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminDashBoard: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/customerAccount/adminDashBoard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {Array} [deviceId] Unique identifier for a device
         * @param {string} [propertyId] Unique identifier for a property
         * @param {string} [customerAccountId] For identifying customer
         * @param {LprLogsSearch} [lprLogsSearch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLprLogsForAdmin: async (size: number, page: number, deviceId?: Array, propertyId?: string, customerAccountId?: string, lprLogsSearch?: LprLogsSearch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'size' is not null or undefined
            assertParamExists('searchLprLogsForAdmin', 'size', size)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('searchLprLogsForAdmin', 'page', page)
            const localVarPath = `/lprLogs/admin/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (propertyId !== undefined) {
                localVarQueryParameter['propertyId'] = propertyId;
            }

            if (customerAccountId !== undefined) {
                localVarQueryParameter['customerAccountId'] = customerAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lprLogsSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserLoginRequest} userLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinadmin: async (userLoginRequest: UserLoginRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userLoginRequest' is not null or undefined
            assertParamExists('signinadmin', 'userLoginRequest', userLoginRequest)
            const localVarPath = `/auth/signinadmin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Access} access 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccess: async (id: string, access: Access, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAccess', 'id', id)
            // verify required parameter 'access' is not null or undefined
            assertParamExists('updateAccess', 'access', access)
            const localVarPath = `/access/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(access, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {CustomerAccount} customerAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerAccountForAdmin: async (id: string, customerAccount: CustomerAccount, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCustomerAccountForAdmin', 'id', id)
            // verify required parameter 'customerAccount' is not null or undefined
            assertParamExists('updateCustomerAccountForAdmin', 'customerAccount', customerAccount)
            const localVarPath = `/customerAccount/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Device} device 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceForAdmin: async (id: string, device: Device, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDeviceForAdmin', 'id', id)
            // verify required parameter 'device' is not null or undefined
            assertParamExists('updateDeviceForAdmin', 'device', device)
            const localVarPath = `/device/admin/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(device, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Order} order 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder: async (id: string, order: Order, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOrder', 'id', id)
            // verify required parameter 'order' is not null or undefined
            assertParamExists('updateOrder', 'order', order)
            const localVarPath = `/order/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(order, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Plan} plan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlan: async (id: string, plan: Plan, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePlan', 'id', id)
            // verify required parameter 'plan' is not null or undefined
            assertParamExists('updatePlan', 'plan', plan)
            const localVarPath = `/plan/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(plan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Role} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole: async (id: string, role: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRole', 'id', id)
            // verify required parameter 'role' is not null or undefined
            assertParamExists('updateRole', 'role', role)
            const localVarPath = `/role/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Screen} screen 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScreen: async (id: string, screen: Screen, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateScreen', 'id', id)
            // verify required parameter 'screen' is not null or undefined
            assertParamExists('updateScreen', 'screen', screen)
            const localVarPath = `/screen/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(screen, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: string, user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUser', 'user', user)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Access} access 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccess(access: Access, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Access>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccess(access, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Order} order 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderAdmin(order: Order, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderAdmin(order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Plan} plan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlan(plan: Plan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlan(plan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Role} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRole(role: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(role, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Screen} screen 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScreen(screen: Screen, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Screen>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScreen(screen, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserForAdmin(user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserForAdmin(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccess(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccess(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomerAccount(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomerAccount(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDeviceForAdmin(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDeviceForAdmin(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrder(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrder(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlan(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlan(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRole(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScreen(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScreen(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllAccesses(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Access>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllAccesses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllCustomerAccount(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomerAccount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllCustomerAccount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [propertyId] Unique identifier for a property
         * @param {string} [customerAccountId] For identifying customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllDeviceForAdmin(propertyId?: string, customerAccountId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllDeviceForAdmin(propertyId, customerAccountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllLastScans(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LastScan>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllLastScans(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {Array} [deviceId] Unique identifier for a device
         * @param {string} [propertyId] Unique identifier for a property
         * @param {string} [customerAccountId] For identifying customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllLprLogsForAdmin(size: number, page: number, deviceId?: Array, propertyId?: string, customerAccountId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LprLogsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllLprLogsForAdmin(size, page, deviceId, propertyId, customerAccountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllOrdersForAdmin(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllOrdersForAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllPlanForAdmin(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Plan>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllPlanForAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [customerAccountId] For identifying customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllPropertyForAdmin(customerAccountId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Property>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllPropertyForAdmin(customerAccountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllRoles(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllRoles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllScreens(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Screen>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllScreens(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllUsersForAdmin(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllUsersForAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOneAccess(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Access>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOneAccess(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {string} [customerAccountId] For identifying customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOneLprLogForAdmin(id: string, customerAccountId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LprLogs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOneLprLogForAdmin(id, customerAccountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOneProcessHeartBeat(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessHeartBeat>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOneProcessHeartBeat(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOneRole(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOneRole(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOneScreen(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Screen>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOneScreen(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOneUser(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOneUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findProcessHeartBeat(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProcessHeartBeat>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findProcessHeartBeat(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdminDashBoard(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdminDashBoard(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {Array} [deviceId] Unique identifier for a device
         * @param {string} [propertyId] Unique identifier for a property
         * @param {string} [customerAccountId] For identifying customer
         * @param {LprLogsSearch} [lprLogsSearch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchLprLogsForAdmin(size: number, page: number, deviceId?: Array, propertyId?: string, customerAccountId?: string, lprLogsSearch?: LprLogsSearch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LprLogsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchLprLogsForAdmin(size, page, deviceId, propertyId, customerAccountId, lprLogsSearch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UserLoginRequest} userLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signinadmin(userLoginRequest: UserLoginRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLoginSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signinadmin(userLoginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Access} access 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccess(id: string, access: Access, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Access>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccess(id, access, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {CustomerAccount} customerAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomerAccountForAdmin(id: string, customerAccount: CustomerAccount, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomerAccountForAdmin(id, customerAccount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Device} device 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDeviceForAdmin(id: string, device: Device, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDeviceForAdmin(id, device, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Order} order 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOrder(id: string, order: Order, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOrder(id, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Plan} plan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlan(id: string, plan: Plan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlan(id, plan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Role} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRole(id: string, role: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(id, role, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Screen} screen 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScreen(id: string, screen: Screen, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Screen>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScreen(id, screen, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: string, user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @param {Access} access 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccess(access: Access, options?: any): AxiosPromise<Access> {
            return localVarFp.createAccess(access, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Order} order 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderAdmin(order: Order, options?: any): AxiosPromise<Order> {
            return localVarFp.createOrderAdmin(order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Plan} plan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlan(plan: Plan, options?: any): AxiosPromise<Plan> {
            return localVarFp.createPlan(plan, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Role} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRole(role: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.createRole(role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Screen} screen 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScreen(screen: Screen, options?: any): AxiosPromise<Screen> {
            return localVarFp.createScreen(screen, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserForAdmin(user: User, options?: any): AxiosPromise<User> {
            return localVarFp.createUserForAdmin(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccess(id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.deleteAccess(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerAccount(id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.deleteCustomerAccount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeviceForAdmin(id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.deleteDeviceForAdmin(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.deleteOrder(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlan(id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.deletePlan(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRole(id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.deleteRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScreen(id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.deleteScreen(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllAccesses(options?: any): AxiosPromise<Array<Access>> {
            return localVarFp.findAllAccesses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllCustomerAccount(options?: any): AxiosPromise<Array<CustomerAccount>> {
            return localVarFp.findAllCustomerAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [propertyId] Unique identifier for a property
         * @param {string} [customerAccountId] For identifying customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDeviceForAdmin(propertyId?: string, customerAccountId?: string, options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.findAllDeviceForAdmin(propertyId, customerAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllLastScans(options?: any): AxiosPromise<Array<LastScan>> {
            return localVarFp.findAllLastScans(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {Array} [deviceId] Unique identifier for a device
         * @param {string} [propertyId] Unique identifier for a property
         * @param {string} [customerAccountId] For identifying customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllLprLogsForAdmin(size: number, page: number, deviceId?: Array, propertyId?: string, customerAccountId?: string, options?: any): AxiosPromise<LprLogsPage> {
            return localVarFp.findAllLprLogsForAdmin(size, page, deviceId, propertyId, customerAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllOrdersForAdmin(options?: any): AxiosPromise<Array<Order>> {
            return localVarFp.findAllOrdersForAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllPlanForAdmin(options?: any): AxiosPromise<Array<Plan>> {
            return localVarFp.findAllPlanForAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [customerAccountId] For identifying customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllPropertyForAdmin(customerAccountId?: string, options?: any): AxiosPromise<Array<Property>> {
            return localVarFp.findAllPropertyForAdmin(customerAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllRoles(options?: any): AxiosPromise<Array<Role>> {
            return localVarFp.findAllRoles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllScreens(options?: any): AxiosPromise<Array<Screen>> {
            return localVarFp.findAllScreens(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllUsersForAdmin(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.findAllUsersForAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneAccess(id: string, options?: any): AxiosPromise<Access> {
            return localVarFp.findOneAccess(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {string} [customerAccountId] For identifying customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneLprLogForAdmin(id: string, customerAccountId?: string, options?: any): AxiosPromise<LprLogs> {
            return localVarFp.findOneLprLogForAdmin(id, customerAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneProcessHeartBeat(id: string, options?: any): AxiosPromise<ProcessHeartBeat> {
            return localVarFp.findOneProcessHeartBeat(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneRole(id: string, options?: any): AxiosPromise<Role> {
            return localVarFp.findOneRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneScreen(id: string, options?: any): AxiosPromise<Screen> {
            return localVarFp.findOneScreen(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneUser(id: string, options?: any): AxiosPromise<User> {
            return localVarFp.findOneUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProcessHeartBeat(options?: any): AxiosPromise<Array<ProcessHeartBeat>> {
            return localVarFp.findProcessHeartBeat(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminDashBoard(options?: any): AxiosPromise<object> {
            return localVarFp.getAdminDashBoard(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {Array} [deviceId] Unique identifier for a device
         * @param {string} [propertyId] Unique identifier for a property
         * @param {string} [customerAccountId] For identifying customer
         * @param {LprLogsSearch} [lprLogsSearch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLprLogsForAdmin(size: number, page: number, deviceId?: Array, propertyId?: string, customerAccountId?: string, lprLogsSearch?: LprLogsSearch, options?: any): AxiosPromise<LprLogsPage> {
            return localVarFp.searchLprLogsForAdmin(size, page, deviceId, propertyId, customerAccountId, lprLogsSearch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserLoginRequest} userLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinadmin(userLoginRequest: UserLoginRequest, options?: any): AxiosPromise<UserLoginSuccess> {
            return localVarFp.signinadmin(userLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Access} access 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccess(id: string, access: Access, options?: any): AxiosPromise<Access> {
            return localVarFp.updateAccess(id, access, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {CustomerAccount} customerAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerAccountForAdmin(id: string, customerAccount: CustomerAccount, options?: any): AxiosPromise<Message> {
            return localVarFp.updateCustomerAccountForAdmin(id, customerAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Device} device 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDeviceForAdmin(id: string, device: Device, options?: any): AxiosPromise<Message> {
            return localVarFp.updateDeviceForAdmin(id, device, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Order} order 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(id: string, order: Order, options?: any): AxiosPromise<Message> {
            return localVarFp.updateOrder(id, order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Plan} plan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlan(id: string, plan: Plan, options?: any): AxiosPromise<Message> {
            return localVarFp.updatePlan(id, plan, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Role} role 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRole(id: string, role: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.updateRole(id, role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Screen} screen 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScreen(id: string, screen: Screen, options?: any): AxiosPromise<Screen> {
            return localVarFp.updateScreen(id, screen, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, user: User, options?: any): AxiosPromise<Message> {
            return localVarFp.updateUser(id, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @param {Access} access 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createAccess(access: Access, options?: any) {
        return AdminApiFp(this.configuration).createAccess(access, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Order} order 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createOrderAdmin(order: Order, options?: any) {
        return AdminApiFp(this.configuration).createOrderAdmin(order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Plan} plan 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createPlan(plan: Plan, options?: any) {
        return AdminApiFp(this.configuration).createPlan(plan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Role} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createRole(role: Role, options?: any) {
        return AdminApiFp(this.configuration).createRole(role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Screen} screen 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createScreen(screen: Screen, options?: any) {
        return AdminApiFp(this.configuration).createScreen(screen, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createUserForAdmin(user: User, options?: any) {
        return AdminApiFp(this.configuration).createUserForAdmin(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteAccess(id: string, options?: any) {
        return AdminApiFp(this.configuration).deleteAccess(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteCustomerAccount(id: string, options?: any) {
        return AdminApiFp(this.configuration).deleteCustomerAccount(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteDeviceForAdmin(id: string, options?: any) {
        return AdminApiFp(this.configuration).deleteDeviceForAdmin(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteOrder(id: string, options?: any) {
        return AdminApiFp(this.configuration).deleteOrder(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deletePlan(id: string, options?: any) {
        return AdminApiFp(this.configuration).deletePlan(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteRole(id: string, options?: any) {
        return AdminApiFp(this.configuration).deleteRole(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteScreen(id: string, options?: any) {
        return AdminApiFp(this.configuration).deleteScreen(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteUser(id: string, options?: any) {
        return AdminApiFp(this.configuration).deleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public findAllAccesses(options?: any) {
        return AdminApiFp(this.configuration).findAllAccesses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public findAllCustomerAccount(options?: any) {
        return AdminApiFp(this.configuration).findAllCustomerAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [propertyId] Unique identifier for a property
     * @param {string} [customerAccountId] For identifying customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public findAllDeviceForAdmin(propertyId?: string, customerAccountId?: string, options?: any) {
        return AdminApiFp(this.configuration).findAllDeviceForAdmin(propertyId, customerAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public findAllLastScans(options?: any) {
        return AdminApiFp(this.configuration).findAllLastScans(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} size 
     * @param {number} page 
     * @param {Array} [deviceId] Unique identifier for a device
     * @param {string} [propertyId] Unique identifier for a property
     * @param {string} [customerAccountId] For identifying customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public findAllLprLogsForAdmin(size: number, page: number, deviceId?: Array, propertyId?: string, customerAccountId?: string, options?: any) {
        return AdminApiFp(this.configuration).findAllLprLogsForAdmin(size, page, deviceId, propertyId, customerAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public findAllOrdersForAdmin(options?: any) {
        return AdminApiFp(this.configuration).findAllOrdersForAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public findAllPlanForAdmin(options?: any) {
        return AdminApiFp(this.configuration).findAllPlanForAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [customerAccountId] For identifying customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public findAllPropertyForAdmin(customerAccountId?: string, options?: any) {
        return AdminApiFp(this.configuration).findAllPropertyForAdmin(customerAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public findAllRoles(options?: any) {
        return AdminApiFp(this.configuration).findAllRoles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public findAllScreens(options?: any) {
        return AdminApiFp(this.configuration).findAllScreens(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public findAllUsersForAdmin(options?: any) {
        return AdminApiFp(this.configuration).findAllUsersForAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public findOneAccess(id: string, options?: any) {
        return AdminApiFp(this.configuration).findOneAccess(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {string} [customerAccountId] For identifying customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public findOneLprLogForAdmin(id: string, customerAccountId?: string, options?: any) {
        return AdminApiFp(this.configuration).findOneLprLogForAdmin(id, customerAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public findOneProcessHeartBeat(id: string, options?: any) {
        return AdminApiFp(this.configuration).findOneProcessHeartBeat(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public findOneRole(id: string, options?: any) {
        return AdminApiFp(this.configuration).findOneRole(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public findOneScreen(id: string, options?: any) {
        return AdminApiFp(this.configuration).findOneScreen(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public findOneUser(id: string, options?: any) {
        return AdminApiFp(this.configuration).findOneUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public findProcessHeartBeat(options?: any) {
        return AdminApiFp(this.configuration).findProcessHeartBeat(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getAdminDashBoard(options?: any) {
        return AdminApiFp(this.configuration).getAdminDashBoard(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} size 
     * @param {number} page 
     * @param {Array} [deviceId] Unique identifier for a device
     * @param {string} [propertyId] Unique identifier for a property
     * @param {string} [customerAccountId] For identifying customer
     * @param {LprLogsSearch} [lprLogsSearch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public searchLprLogsForAdmin(size: number, page: number, deviceId?: Array, propertyId?: string, customerAccountId?: string, lprLogsSearch?: LprLogsSearch, options?: any) {
        return AdminApiFp(this.configuration).searchLprLogsForAdmin(size, page, deviceId, propertyId, customerAccountId, lprLogsSearch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserLoginRequest} userLoginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public signinadmin(userLoginRequest: UserLoginRequest, options?: any) {
        return AdminApiFp(this.configuration).signinadmin(userLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {Access} access 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateAccess(id: string, access: Access, options?: any) {
        return AdminApiFp(this.configuration).updateAccess(id, access, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {CustomerAccount} customerAccount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateCustomerAccountForAdmin(id: string, customerAccount: CustomerAccount, options?: any) {
        return AdminApiFp(this.configuration).updateCustomerAccountForAdmin(id, customerAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {Device} device 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateDeviceForAdmin(id: string, device: Device, options?: any) {
        return AdminApiFp(this.configuration).updateDeviceForAdmin(id, device, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {Order} order 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateOrder(id: string, order: Order, options?: any) {
        return AdminApiFp(this.configuration).updateOrder(id, order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {Plan} plan 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updatePlan(id: string, plan: Plan, options?: any) {
        return AdminApiFp(this.configuration).updatePlan(id, plan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {Role} role 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateRole(id: string, role: Role, options?: any) {
        return AdminApiFp(this.configuration).updateRole(id, role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {Screen} screen 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateScreen(id: string, screen: Screen, options?: any) {
        return AdminApiFp(this.configuration).updateScreen(id, screen, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateUser(id: string, user: User, options?: any) {
        return AdminApiFp(this.configuration).updateUser(id, user, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
            assertParamExists('changePassword', 'uNKNOWNBASETYPE', uNKNOWNBASETYPE)
            const localVarPath = `/auth/changepassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailVerify: async (token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('emailVerify', 'token', token)
            const localVarPath = `/auth/emailVerify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgetPassword: async (uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
            assertParamExists('forgetPassword', 'uNKNOWNBASETYPE', uNKNOWNBASETYPE)
            const localVarPath = `/auth/forgetpassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renewToken: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/renewToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uNKNOWNBASETYPE' is not null or undefined
            assertParamExists('resetPassword', 'uNKNOWNBASETYPE', uNKNOWNBASETYPE)
            const localVarPath = `/auth/resetpassword`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ProviderSignIn} providerSignIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInFromProvider: async (providerSignIn: ProviderSignIn, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'providerSignIn' is not null or undefined
            assertParamExists('signInFromProvider', 'providerSignIn', providerSignIn)
            const localVarPath = `/auth/signinfromprovider`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(providerSignIn, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserLoginRequest} userLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signin: async (userLoginRequest: UserLoginRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userLoginRequest' is not null or undefined
            assertParamExists('signin', 'userLoginRequest', userLoginRequest)
            const localVarPath = `/auth/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserRegister} userRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup: async (userRegister: UserRegister, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userRegister' is not null or undefined
            assertParamExists('signup', 'userRegister', userRegister)
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailVerify(token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailVerify(token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgetPassword(uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgetPassword(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renewToken(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renewToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ProviderSignIn} providerSignIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signInFromProvider(providerSignIn: ProviderSignIn, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLoginSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signInFromProvider(providerSignIn, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UserLoginRequest} userLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signin(userLoginRequest: UserLoginRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserLoginSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signin(userLoginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UserRegister} userRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signup(userRegister: UserRegister, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signup(userRegister, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<Message> {
            return localVarFp.changePassword(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailVerify(token: string, options?: any): AxiosPromise<object> {
            return localVarFp.emailVerify(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgetPassword(uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<Message> {
            return localVarFp.forgetPassword(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renewToken(options?: any): AxiosPromise<object> {
            return localVarFp.renewToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<Message> {
            return localVarFp.resetPassword(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ProviderSignIn} providerSignIn 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInFromProvider(providerSignIn: ProviderSignIn, options?: any): AxiosPromise<UserLoginSuccess> {
            return localVarFp.signInFromProvider(providerSignIn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserLoginRequest} userLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signin(userLoginRequest: UserLoginRequest, options?: any): AxiosPromise<UserLoginSuccess> {
            return localVarFp.signin(userLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserRegister} userRegister 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signup(userRegister: UserRegister, options?: any): AxiosPromise<User> {
            return localVarFp.signup(userRegister, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public changePassword(uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options?: any) {
        return AuthenticationApiFp(this.configuration).changePassword(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public emailVerify(token: string, options?: any) {
        return AuthenticationApiFp(this.configuration).emailVerify(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public forgetPassword(uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options?: any) {
        return AuthenticationApiFp(this.configuration).forgetPassword(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public renewToken(options?: any) {
        return AuthenticationApiFp(this.configuration).renewToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UNKNOWN_BASE_TYPE} uNKNOWNBASETYPE 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public resetPassword(uNKNOWNBASETYPE: UNKNOWN_BASE_TYPE, options?: any) {
        return AuthenticationApiFp(this.configuration).resetPassword(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ProviderSignIn} providerSignIn 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public signInFromProvider(providerSignIn: ProviderSignIn, options?: any) {
        return AuthenticationApiFp(this.configuration).signInFromProvider(providerSignIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserLoginRequest} userLoginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public signin(userLoginRequest: UserLoginRequest, options?: any) {
        return AuthenticationApiFp(this.configuration).signin(userLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserRegister} userRegister 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public signup(userRegister: UserRegister, options?: any) {
        return AuthenticationApiFp(this.configuration).signup(userRegister, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BookmarkApi - axios parameter creator
 * @export
 */
export const BookmarkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookmark: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createBookmark', 'id', id)
            const localVarPath = `/bookmark/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookmark: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteBookmark', 'id', id)
            const localVarPath = `/bookmark/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllBookmarks: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/bookmark`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneBookmark: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOneBookmark', 'id', id)
            const localVarPath = `/bookmark/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookmarkApi - functional programming interface
 * @export
 */
export const BookmarkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookmarkApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBookmark(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBookmark(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBookmark(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBookmark(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllBookmarks(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bookmark>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllBookmarks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOneBookmark(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bookmark>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOneBookmark(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BookmarkApi - factory interface
 * @export
 */
export const BookmarkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookmarkApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookmark(id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.createBookmark(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBookmark(id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.deleteBookmark(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllBookmarks(options?: any): AxiosPromise<Bookmark> {
            return localVarFp.findAllBookmarks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneBookmark(id: string, options?: any): AxiosPromise<Bookmark> {
            return localVarFp.findOneBookmark(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookmarkApi - object-oriented interface
 * @export
 * @class BookmarkApi
 * @extends {BaseAPI}
 */
export class BookmarkApi extends BaseAPI {
    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarkApi
     */
    public createBookmark(id: string, options?: any) {
        return BookmarkApiFp(this.configuration).createBookmark(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarkApi
     */
    public deleteBookmark(id: string, options?: any) {
        return BookmarkApiFp(this.configuration).deleteBookmark(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarkApi
     */
    public findAllBookmarks(options?: any) {
        return BookmarkApiFp(this.configuration).findAllBookmarks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarkApi
     */
    public findOneBookmark(id: string, options?: any) {
        return BookmarkApiFp(this.configuration).findOneBookmark(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomerAccountApi - axios parameter creator
 * @export
 */
export const CustomerAccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CustomerAccount} customerAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerAccount: async (customerAccount: CustomerAccount, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerAccount' is not null or undefined
            assertParamExists('createCustomerAccount', 'customerAccount', customerAccount)
            const localVarPath = `/customerAccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneCustomerAccount: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/customerAccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDashBoard: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/customerAccount/dashBoard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CustomerAccount} customerAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerAccount: async (customerAccount: CustomerAccount, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerAccount' is not null or undefined
            assertParamExists('updateCustomerAccount', 'customerAccount', customerAccount)
            const localVarPath = `/customerAccount/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerAccountApi - functional programming interface
 * @export
 */
export const CustomerAccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerAccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CustomerAccount} customerAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomerAccount(customerAccount: CustomerAccount, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomerAccount(customerAccount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOneCustomerAccount(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOneCustomerAccount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerDashBoard(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerDashBoard(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CustomerAccount} customerAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomerAccount(customerAccount: CustomerAccount, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomerAccount(customerAccount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomerAccountApi - factory interface
 * @export
 */
export const CustomerAccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerAccountApiFp(configuration)
    return {
        /**
         * 
         * @param {CustomerAccount} customerAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerAccount(customerAccount: CustomerAccount, options?: any): AxiosPromise<CustomerAccount> {
            return localVarFp.createCustomerAccount(customerAccount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneCustomerAccount(options?: any): AxiosPromise<CustomerAccount> {
            return localVarFp.findOneCustomerAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerDashBoard(options?: any): AxiosPromise<object> {
            return localVarFp.getCustomerDashBoard(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CustomerAccount} customerAccount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerAccount(customerAccount: CustomerAccount, options?: any): AxiosPromise<Message> {
            return localVarFp.updateCustomerAccount(customerAccount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerAccountApi - object-oriented interface
 * @export
 * @class CustomerAccountApi
 * @extends {BaseAPI}
 */
export class CustomerAccountApi extends BaseAPI {
    /**
     * 
     * @param {CustomerAccount} customerAccount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountApi
     */
    public createCustomerAccount(customerAccount: CustomerAccount, options?: any) {
        return CustomerAccountApiFp(this.configuration).createCustomerAccount(customerAccount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountApi
     */
    public findOneCustomerAccount(options?: any) {
        return CustomerAccountApiFp(this.configuration).findOneCustomerAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountApi
     */
    public getCustomerDashBoard(options?: any) {
        return CustomerAccountApiFp(this.configuration).getCustomerDashBoard(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CustomerAccount} customerAccount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerAccountApi
     */
    public updateCustomerAccount(customerAccount: CustomerAccount, options?: any) {
        return CustomerAccountApiFp(this.configuration).updateCustomerAccount(customerAccount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomerCardApi - axios parameter creator
 * @export
 */
export const CustomerCardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CustomerCard} customerCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerCard: async (customerCard: CustomerCard, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerCard' is not null or undefined
            assertParamExists('createCustomerCard', 'customerCard', customerCard)
            const localVarPath = `/customerCard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerCard, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerCard: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCustomerCard', 'id', id)
            const localVarPath = `/customerCard/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllCustomerCard: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/customerCard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneCustomerCard: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOneCustomerCard', 'id', id)
            const localVarPath = `/customerCard/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {CustomerCard} customerCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerCard: async (id: string, customerCard: CustomerCard, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCustomerCard', 'id', id)
            // verify required parameter 'customerCard' is not null or undefined
            assertParamExists('updateCustomerCard', 'customerCard', customerCard)
            const localVarPath = `/customerCard/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerCard, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerCardApi - functional programming interface
 * @export
 */
export const CustomerCardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerCardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CustomerCard} customerCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomerCard(customerCard: CustomerCard, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerCard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomerCard(customerCard, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomerCard(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomerCard(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllCustomerCard(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomerCard>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllCustomerCard(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOneCustomerCard(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerCard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOneCustomerCard(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {CustomerCard} customerCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomerCard(id: string, customerCard: CustomerCard, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomerCard(id, customerCard, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomerCardApi - factory interface
 * @export
 */
export const CustomerCardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerCardApiFp(configuration)
    return {
        /**
         * 
         * @param {CustomerCard} customerCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerCard(customerCard: CustomerCard, options?: any): AxiosPromise<CustomerCard> {
            return localVarFp.createCustomerCard(customerCard, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerCard(id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.deleteCustomerCard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllCustomerCard(options?: any): AxiosPromise<Array<CustomerCard>> {
            return localVarFp.findAllCustomerCard(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneCustomerCard(id: string, options?: any): AxiosPromise<CustomerCard> {
            return localVarFp.findOneCustomerCard(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {CustomerCard} customerCard 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerCard(id: string, customerCard: CustomerCard, options?: any): AxiosPromise<Message> {
            return localVarFp.updateCustomerCard(id, customerCard, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerCardApi - object-oriented interface
 * @export
 * @class CustomerCardApi
 * @extends {BaseAPI}
 */
export class CustomerCardApi extends BaseAPI {
    /**
     * 
     * @param {CustomerCard} customerCard 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCardApi
     */
    public createCustomerCard(customerCard: CustomerCard, options?: any) {
        return CustomerCardApiFp(this.configuration).createCustomerCard(customerCard, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCardApi
     */
    public deleteCustomerCard(id: string, options?: any) {
        return CustomerCardApiFp(this.configuration).deleteCustomerCard(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCardApi
     */
    public findAllCustomerCard(options?: any) {
        return CustomerCardApiFp(this.configuration).findAllCustomerCard(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCardApi
     */
    public findOneCustomerCard(id: string, options?: any) {
        return CustomerCardApiFp(this.configuration).findOneCustomerCard(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {CustomerCard} customerCard 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCardApi
     */
    public updateCustomerCard(id: string, customerCard: CustomerCard, options?: any) {
        return CustomerCardApiFp(this.configuration).updateCustomerCard(id, customerCard, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomerPlanApi - axios parameter creator
 * @export
 */
export const CustomerPlanApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CustomerPlan} customerPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPlan: async (customerPlan: CustomerPlan, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerPlan' is not null or undefined
            assertParamExists('createCustomerPlan', 'customerPlan', customerPlan)
            const localVarPath = `/customerPlan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerPlan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerPlan: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCustomerPlan', 'id', id)
            const localVarPath = `/customerPlan/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [available] 
         * @param {string} [customerAccountId] For identifying customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllCustomerPlan: async (available?: boolean, customerAccountId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/customerPlan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (available !== undefined) {
                localVarQueryParameter['available'] = available;
            }

            if (customerAccountId !== undefined) {
                localVarQueryParameter['customerAccountId'] = customerAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneCustomerPlan: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOneCustomerPlan', 'id', id)
            const localVarPath = `/customerPlan/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {CustomerPlan} customerPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPlan: async (id: string, customerPlan: CustomerPlan, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCustomerPlan', 'id', id)
            // verify required parameter 'customerPlan' is not null or undefined
            assertParamExists('updateCustomerPlan', 'customerPlan', customerPlan)
            const localVarPath = `/customerPlan/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerPlan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerPlanApi - functional programming interface
 * @export
 */
export const CustomerPlanApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerPlanApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CustomerPlan} customerPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomerPlan(customerPlan: CustomerPlan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomerPlan(customerPlan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomerPlan(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomerPlan(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [available] 
         * @param {string} [customerAccountId] For identifying customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllCustomerPlan(available?: boolean, customerAccountId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomerPlan>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllCustomerPlan(available, customerAccountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOneCustomerPlan(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOneCustomerPlan(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {CustomerPlan} customerPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomerPlan(id: string, customerPlan: CustomerPlan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomerPlan(id, customerPlan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomerPlanApi - factory interface
 * @export
 */
export const CustomerPlanApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerPlanApiFp(configuration)
    return {
        /**
         * 
         * @param {CustomerPlan} customerPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerPlan(customerPlan: CustomerPlan, options?: any): AxiosPromise<CustomerPlan> {
            return localVarFp.createCustomerPlan(customerPlan, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerPlan(id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.deleteCustomerPlan(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [available] 
         * @param {string} [customerAccountId] For identifying customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllCustomerPlan(available?: boolean, customerAccountId?: string, options?: any): AxiosPromise<Array<CustomerPlan>> {
            return localVarFp.findAllCustomerPlan(available, customerAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneCustomerPlan(id: string, options?: any): AxiosPromise<CustomerPlan> {
            return localVarFp.findOneCustomerPlan(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {CustomerPlan} customerPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomerPlan(id: string, customerPlan: CustomerPlan, options?: any): AxiosPromise<Message> {
            return localVarFp.updateCustomerPlan(id, customerPlan, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerPlanApi - object-oriented interface
 * @export
 * @class CustomerPlanApi
 * @extends {BaseAPI}
 */
export class CustomerPlanApi extends BaseAPI {
    /**
     * 
     * @param {CustomerPlan} customerPlan 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerPlanApi
     */
    public createCustomerPlan(customerPlan: CustomerPlan, options?: any) {
        return CustomerPlanApiFp(this.configuration).createCustomerPlan(customerPlan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerPlanApi
     */
    public deleteCustomerPlan(id: string, options?: any) {
        return CustomerPlanApiFp(this.configuration).deleteCustomerPlan(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [available] 
     * @param {string} [customerAccountId] For identifying customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerPlanApi
     */
    public findAllCustomerPlan(available?: boolean, customerAccountId?: string, options?: any) {
        return CustomerPlanApiFp(this.configuration).findAllCustomerPlan(available, customerAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerPlanApi
     */
    public findOneCustomerPlan(id: string, options?: any) {
        return CustomerPlanApiFp(this.configuration).findOneCustomerPlan(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {CustomerPlan} customerPlan 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerPlanApi
     */
    public updateCustomerPlan(id: string, customerPlan: CustomerPlan, options?: any) {
        return CustomerPlanApiFp(this.configuration).updateCustomerPlan(id, customerPlan, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeviceApi - axios parameter creator
 * @export
 */
export const DeviceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Device} device 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectAndRetrive: async (device: Device, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'device' is not null or undefined
            assertParamExists('connectAndRetrive', 'device', device)
            const localVarPath = `/device/connectAndRetrive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(device, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Device} device 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDevice: async (device: Device, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'device' is not null or undefined
            assertParamExists('createDevice', 'device', device)
            const localVarPath = `/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(device, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {string} [propertyId] Unique identifier for a property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice: async (id: string, propertyId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDevice', 'id', id)
            const localVarPath = `/device/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)

            if (propertyId !== undefined) {
                localVarQueryParameter['propertyId'] = propertyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [propertyId] Unique identifier for a property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDevice: async (propertyId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (propertyId !== undefined) {
                localVarQueryParameter['propertyId'] = propertyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneDevice: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOneDevice', 'id', id)
            const localVarPath = `/device/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [deviceId] Unique identifier for a device
         * @param {number} [customerPlanId] Unique identifier for a customerPlanId
         * @param {number} [existingPlanId] Unique identifier for a existingPlanId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPlan: async (deviceId?: number, customerPlanId?: number, existingPlanId?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/device/modifyPlan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (customerPlanId !== undefined) {
                localVarQueryParameter['customerPlanId'] = customerPlanId;
            }

            if (existingPlanId !== undefined) {
                localVarQueryParameter['existingPlanId'] = existingPlanId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Device} device 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice: async (id: string, device: Device, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDevice', 'id', id)
            // verify required parameter 'device' is not null or undefined
            assertParamExists('updateDevice', 'device', device)
            const localVarPath = `/device/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(device, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceApi - functional programming interface
 * @export
 */
export const DeviceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Device} device 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectAndRetrive(device: Device, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectAndRetrive(device, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Device} device 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDevice(device: Device, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDevice(device, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {string} [propertyId] Unique identifier for a property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDevice(id: string, propertyId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDevice(id, propertyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [propertyId] Unique identifier for a property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllDevice(propertyId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Device>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllDevice(propertyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOneDevice(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOneDevice(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [deviceId] Unique identifier for a device
         * @param {number} [customerPlanId] Unique identifier for a customerPlanId
         * @param {number} [existingPlanId] Unique identifier for a existingPlanId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyPlan(deviceId?: number, customerPlanId?: number, existingPlanId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyPlan(deviceId, customerPlanId, existingPlanId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Device} device 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDevice(id: string, device: Device, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDevice(id, device, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeviceApi - factory interface
 * @export
 */
export const DeviceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceApiFp(configuration)
    return {
        /**
         * 
         * @param {Device} device 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectAndRetrive(device: Device, options?: any): AxiosPromise<string> {
            return localVarFp.connectAndRetrive(device, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Device} device 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDevice(device: Device, options?: any): AxiosPromise<Device> {
            return localVarFp.createDevice(device, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {string} [propertyId] Unique identifier for a property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDevice(id: string, propertyId?: string, options?: any): AxiosPromise<Message> {
            return localVarFp.deleteDevice(id, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [propertyId] Unique identifier for a property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDevice(propertyId?: string, options?: any): AxiosPromise<Array<Device>> {
            return localVarFp.findAllDevice(propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneDevice(id: string, options?: any): AxiosPromise<Device> {
            return localVarFp.findOneDevice(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [deviceId] Unique identifier for a device
         * @param {number} [customerPlanId] Unique identifier for a customerPlanId
         * @param {number} [existingPlanId] Unique identifier for a existingPlanId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPlan(deviceId?: number, customerPlanId?: number, existingPlanId?: number, options?: any): AxiosPromise<Message> {
            return localVarFp.modifyPlan(deviceId, customerPlanId, existingPlanId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Device} device 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDevice(id: string, device: Device, options?: any): AxiosPromise<Message> {
            return localVarFp.updateDevice(id, device, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeviceApi - object-oriented interface
 * @export
 * @class DeviceApi
 * @extends {BaseAPI}
 */
export class DeviceApi extends BaseAPI {
    /**
     * 
     * @param {Device} device 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public connectAndRetrive(device: Device, options?: any) {
        return DeviceApiFp(this.configuration).connectAndRetrive(device, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Device} device 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public createDevice(device: Device, options?: any) {
        return DeviceApiFp(this.configuration).createDevice(device, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {string} [propertyId] Unique identifier for a property
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public deleteDevice(id: string, propertyId?: string, options?: any) {
        return DeviceApiFp(this.configuration).deleteDevice(id, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [propertyId] Unique identifier for a property
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public findAllDevice(propertyId?: string, options?: any) {
        return DeviceApiFp(this.configuration).findAllDevice(propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public findOneDevice(id: string, options?: any) {
        return DeviceApiFp(this.configuration).findOneDevice(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [deviceId] Unique identifier for a device
     * @param {number} [customerPlanId] Unique identifier for a customerPlanId
     * @param {number} [existingPlanId] Unique identifier for a existingPlanId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public modifyPlan(deviceId?: number, customerPlanId?: number, existingPlanId?: number, options?: any) {
        return DeviceApiFp(this.configuration).modifyPlan(deviceId, customerPlanId, existingPlanId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {Device} device 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public updateDevice(id: string, device: Device, options?: any) {
        return DeviceApiFp(this.configuration).updateDevice(id, device, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LastScanApi - axios parameter creator
 * @export
 */
export const LastScanApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneLastScan: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOneLastScan', 'id', id)
            const localVarPath = `/lastScan/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LastScanApi - functional programming interface
 * @export
 */
export const LastScanApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LastScanApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOneLastScan(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LastScan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOneLastScan(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LastScanApi - factory interface
 * @export
 */
export const LastScanApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LastScanApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneLastScan(id: string, options?: any): AxiosPromise<LastScan> {
            return localVarFp.findOneLastScan(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LastScanApi - object-oriented interface
 * @export
 * @class LastScanApi
 * @extends {BaseAPI}
 */
export class LastScanApi extends BaseAPI {
    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LastScanApi
     */
    public findOneLastScan(id: string, options?: any) {
        return LastScanApiFp(this.configuration).findOneLastScan(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LprLogsApi - axios parameter creator
 * @export
 */
export const LprLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {Array} [deviceId] Unique identifier for a device
         * @param {string} [propertyId] Unique identifier for a property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllLprLogs: async (size: number, page: number, deviceId?: Array, propertyId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'size' is not null or undefined
            assertParamExists('findAllLprLogs', 'size', size)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('findAllLprLogs', 'page', page)
            const localVarPath = `/lprLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (propertyId !== undefined) {
                localVarQueryParameter['propertyId'] = propertyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneLprLog: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOneLprLog', 'id', id)
            const localVarPath = `/lprLogs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {Array} [deviceId] Unique identifier for a device
         * @param {string} [propertyId] Unique identifier for a property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (size: number, page: number, deviceId?: Array, propertyId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'size' is not null or undefined
            assertParamExists('getNotifications', 'size', size)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getNotifications', 'page', page)
            const localVarPath = `/lprLogs/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (propertyId !== undefined) {
                localVarQueryParameter['propertyId'] = propertyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {Array} [deviceId] Unique identifier for a device
         * @param {string} [propertyId] Unique identifier for a property
         * @param {LprLogsSearch} [lprLogsSearch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLprLogs: async (size: number, page: number, deviceId?: Array, propertyId?: string, lprLogsSearch?: LprLogsSearch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'size' is not null or undefined
            assertParamExists('searchLprLogs', 'size', size)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('searchLprLogs', 'page', page)
            const localVarPath = `/lprLogs/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (propertyId !== undefined) {
                localVarQueryParameter['propertyId'] = propertyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lprLogsSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {Array} [deviceId] Unique identifier for a device
         * @param {string} [propertyId] Unique identifier for a property
         * @param {LprLogsSearch} [lprLogsSearch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchNotificationLprLogs: async (size: number, page: number, deviceId?: Array, propertyId?: string, lprLogsSearch?: LprLogsSearch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'size' is not null or undefined
            assertParamExists('searchNotificationLprLogs', 'size', size)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('searchNotificationLprLogs', 'page', page)
            const localVarPath = `/lprLogs/notifications/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['deviceId'] = deviceId;
            }

            if (propertyId !== undefined) {
                localVarQueryParameter['propertyId'] = propertyId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(lprLogsSearch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LprLogsApi - functional programming interface
 * @export
 */
export const LprLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LprLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {Array} [deviceId] Unique identifier for a device
         * @param {string} [propertyId] Unique identifier for a property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllLprLogs(size: number, page: number, deviceId?: Array, propertyId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LprLogsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllLprLogs(size, page, deviceId, propertyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOneLprLog(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LprLogs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOneLprLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {Array} [deviceId] Unique identifier for a device
         * @param {string} [propertyId] Unique identifier for a property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(size: number, page: number, deviceId?: Array, propertyId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LprLogsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotifications(size, page, deviceId, propertyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {Array} [deviceId] Unique identifier for a device
         * @param {string} [propertyId] Unique identifier for a property
         * @param {LprLogsSearch} [lprLogsSearch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchLprLogs(size: number, page: number, deviceId?: Array, propertyId?: string, lprLogsSearch?: LprLogsSearch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LprLogsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchLprLogs(size, page, deviceId, propertyId, lprLogsSearch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {Array} [deviceId] Unique identifier for a device
         * @param {string} [propertyId] Unique identifier for a property
         * @param {LprLogsSearch} [lprLogsSearch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchNotificationLprLogs(size: number, page: number, deviceId?: Array, propertyId?: string, lprLogsSearch?: LprLogsSearch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LprLogsPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchNotificationLprLogs(size, page, deviceId, propertyId, lprLogsSearch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LprLogsApi - factory interface
 * @export
 */
export const LprLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LprLogsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {Array} [deviceId] Unique identifier for a device
         * @param {string} [propertyId] Unique identifier for a property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllLprLogs(size: number, page: number, deviceId?: Array, propertyId?: string, options?: any): AxiosPromise<LprLogsPage> {
            return localVarFp.findAllLprLogs(size, page, deviceId, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneLprLog(id: string, options?: any): AxiosPromise<LprLogs> {
            return localVarFp.findOneLprLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {Array} [deviceId] Unique identifier for a device
         * @param {string} [propertyId] Unique identifier for a property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(size: number, page: number, deviceId?: Array, propertyId?: string, options?: any): AxiosPromise<LprLogsPage> {
            return localVarFp.getNotifications(size, page, deviceId, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {Array} [deviceId] Unique identifier for a device
         * @param {string} [propertyId] Unique identifier for a property
         * @param {LprLogsSearch} [lprLogsSearch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchLprLogs(size: number, page: number, deviceId?: Array, propertyId?: string, lprLogsSearch?: LprLogsSearch, options?: any): AxiosPromise<LprLogsPage> {
            return localVarFp.searchLprLogs(size, page, deviceId, propertyId, lprLogsSearch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {Array} [deviceId] Unique identifier for a device
         * @param {string} [propertyId] Unique identifier for a property
         * @param {LprLogsSearch} [lprLogsSearch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchNotificationLprLogs(size: number, page: number, deviceId?: Array, propertyId?: string, lprLogsSearch?: LprLogsSearch, options?: any): AxiosPromise<LprLogsPage> {
            return localVarFp.searchNotificationLprLogs(size, page, deviceId, propertyId, lprLogsSearch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LprLogsApi - object-oriented interface
 * @export
 * @class LprLogsApi
 * @extends {BaseAPI}
 */
export class LprLogsApi extends BaseAPI {
    /**
     * 
     * @param {number} size 
     * @param {number} page 
     * @param {Array} [deviceId] Unique identifier for a device
     * @param {string} [propertyId] Unique identifier for a property
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LprLogsApi
     */
    public findAllLprLogs(size: number, page: number, deviceId?: Array, propertyId?: string, options?: any) {
        return LprLogsApiFp(this.configuration).findAllLprLogs(size, page, deviceId, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LprLogsApi
     */
    public findOneLprLog(id: string, options?: any) {
        return LprLogsApiFp(this.configuration).findOneLprLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} size 
     * @param {number} page 
     * @param {Array} [deviceId] Unique identifier for a device
     * @param {string} [propertyId] Unique identifier for a property
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LprLogsApi
     */
    public getNotifications(size: number, page: number, deviceId?: Array, propertyId?: string, options?: any) {
        return LprLogsApiFp(this.configuration).getNotifications(size, page, deviceId, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} size 
     * @param {number} page 
     * @param {Array} [deviceId] Unique identifier for a device
     * @param {string} [propertyId] Unique identifier for a property
     * @param {LprLogsSearch} [lprLogsSearch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LprLogsApi
     */
    public searchLprLogs(size: number, page: number, deviceId?: Array, propertyId?: string, lprLogsSearch?: LprLogsSearch, options?: any) {
        return LprLogsApiFp(this.configuration).searchLprLogs(size, page, deviceId, propertyId, lprLogsSearch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} size 
     * @param {number} page 
     * @param {Array} [deviceId] Unique identifier for a device
     * @param {string} [propertyId] Unique identifier for a property
     * @param {LprLogsSearch} [lprLogsSearch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LprLogsApi
     */
    public searchNotificationLprLogs(size: number, page: number, deviceId?: Array, propertyId?: string, lprLogsSearch?: LprLogsSearch, options?: any) {
        return LprLogsApiFp(this.configuration).searchNotificationLprLogs(size, page, deviceId, propertyId, lprLogsSearch, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NotificationApi - axios parameter creator
 * @export
 */
export const NotificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Notification} notification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotification: async (notification: Notification, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'notification' is not null or undefined
            assertParamExists('createNotification', 'notification', notification)
            const localVarPath = `/notificationSetting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notification, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteNotification', 'id', id)
            const localVarPath = `/notificationSetting/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllNotification: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/notificationSetting`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOnePropertyNotification: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOnePropertyNotification', 'id', id)
            const localVarPath = `/notificationSetting/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Notification} notification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotification: async (id: string, notification: Notification, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateNotification', 'id', id)
            // verify required parameter 'notification' is not null or undefined
            assertParamExists('updateNotification', 'notification', notification)
            const localVarPath = `/notificationSetting/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notification, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationApi - functional programming interface
 * @export
 */
export const NotificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Notification} notification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNotification(notification: Notification, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNotification(notification, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNotification(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNotification(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllNotification(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Notification>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllNotification(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOnePropertyNotification(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Notification>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOnePropertyNotification(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Notification} notification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNotification(id: string, notification: Notification, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNotification(id, notification, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NotificationApi - factory interface
 * @export
 */
export const NotificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationApiFp(configuration)
    return {
        /**
         * 
         * @param {Notification} notification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNotification(notification: Notification, options?: any): AxiosPromise<Notification> {
            return localVarFp.createNotification(notification, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNotification(id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.deleteNotification(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllNotification(options?: any): AxiosPromise<Array<Notification>> {
            return localVarFp.findAllNotification(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOnePropertyNotification(id: string, options?: any): AxiosPromise<Array<Notification>> {
            return localVarFp.findOnePropertyNotification(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Notification} notification 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNotification(id: string, notification: Notification, options?: any): AxiosPromise<Message> {
            return localVarFp.updateNotification(id, notification, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationApi - object-oriented interface
 * @export
 * @class NotificationApi
 * @extends {BaseAPI}
 */
export class NotificationApi extends BaseAPI {
    /**
     * 
     * @param {Notification} notification 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public createNotification(notification: Notification, options?: any) {
        return NotificationApiFp(this.configuration).createNotification(notification, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public deleteNotification(id: string, options?: any) {
        return NotificationApiFp(this.configuration).deleteNotification(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public findAllNotification(options?: any) {
        return NotificationApiFp(this.configuration).findAllNotification(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public findOnePropertyNotification(id: string, options?: any) {
        return NotificationApiFp(this.configuration).findOnePropertyNotification(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {Notification} notification 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationApi
     */
    public updateNotification(id: string, notification: Notification, options?: any) {
        return NotificationApiFp(this.configuration).updateNotification(id, notification, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Order} order 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder: async (order: Order, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('createOrder', 'order', order)
            const localVarPath = `/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(order, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadInvoice: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadInvoice', 'id', id)
            const localVarPath = `/order/invoice/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllOrder: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneOrder: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOneOrder', 'id', id)
            const localVarPath = `/order/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Order} order 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrder(order: Order, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrder(order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadInvoice(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadInvoice(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllOrder(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Order>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllOrder(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOneOrder(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOneOrder(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderApiFp(configuration)
    return {
        /**
         * 
         * @param {Order} order 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(order: Order, options?: any): AxiosPromise<Order> {
            return localVarFp.createOrder(order, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadInvoice(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.downloadInvoice(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllOrder(options?: any): AxiosPromise<Array<Order>> {
            return localVarFp.findAllOrder(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneOrder(id: string, options?: any): AxiosPromise<Order> {
            return localVarFp.findOneOrder(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     * 
     * @param {Order} order 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public createOrder(order: Order, options?: any) {
        return OrderApiFp(this.configuration).createOrder(order, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public downloadInvoice(id: string, options?: any) {
        return OrderApiFp(this.configuration).downloadInvoice(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public findAllOrder(options?: any) {
        return OrderApiFp(this.configuration).findAllOrder(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public findOneOrder(id: string, options?: any) {
        return OrderApiFp(this.configuration).findOneOrder(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PermitApi - axios parameter creator
 * @export
 */
export const PermitApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Permit} permit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPermit: async (permit: Permit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'permit' is not null or undefined
            assertParamExists('createPermit', 'permit', permit)
            const localVarPath = `/permit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(permit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermit: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePermit', 'id', id)
            const localVarPath = `/permit/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {string} [propertyId] Unique identifier for a property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllPermits: async (size: number, page: number, propertyId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'size' is not null or undefined
            assertParamExists('findAllPermits', 'size', size)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('findAllPermits', 'page', page)
            const localVarPath = `/permit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (propertyId !== undefined) {
                localVarQueryParameter['propertyId'] = propertyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOnePermit: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOnePermit', 'id', id)
            const localVarPath = `/permit/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Permit} permit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermit: async (id: string, permit: Permit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePermit', 'id', id)
            // verify required parameter 'permit' is not null or undefined
            assertParamExists('updatePermit', 'permit', permit)
            const localVarPath = `/permit/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(permit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermitApi - functional programming interface
 * @export
 */
export const PermitApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermitApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Permit} permit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPermit(permit: Permit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPermit(permit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePermit(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePermit(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {string} [propertyId] Unique identifier for a property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllPermits(size: number, page: number, propertyId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PermitPage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllPermits(size, page, propertyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOnePermit(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOnePermit(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Permit} permit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePermit(id: string, permit: Permit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Permit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePermit(id, permit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PermitApi - factory interface
 * @export
 */
export const PermitApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermitApiFp(configuration)
    return {
        /**
         * 
         * @param {Permit} permit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPermit(permit: Permit, options?: any): AxiosPromise<Permit> {
            return localVarFp.createPermit(permit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermit(id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.deletePermit(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {string} [propertyId] Unique identifier for a property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllPermits(size: number, page: number, propertyId?: string, options?: any): AxiosPromise<Array<PermitPage>> {
            return localVarFp.findAllPermits(size, page, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOnePermit(id: string, options?: any): AxiosPromise<Permit> {
            return localVarFp.findOnePermit(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Permit} permit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermit(id: string, permit: Permit, options?: any): AxiosPromise<Permit> {
            return localVarFp.updatePermit(id, permit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermitApi - object-oriented interface
 * @export
 * @class PermitApi
 * @extends {BaseAPI}
 */
export class PermitApi extends BaseAPI {
    /**
     * 
     * @param {Permit} permit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermitApi
     */
    public createPermit(permit: Permit, options?: any) {
        return PermitApiFp(this.configuration).createPermit(permit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermitApi
     */
    public deletePermit(id: string, options?: any) {
        return PermitApiFp(this.configuration).deletePermit(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} size 
     * @param {number} page 
     * @param {string} [propertyId] Unique identifier for a property
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermitApi
     */
    public findAllPermits(size: number, page: number, propertyId?: string, options?: any) {
        return PermitApiFp(this.configuration).findAllPermits(size, page, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermitApi
     */
    public findOnePermit(id: string, options?: any) {
        return PermitApiFp(this.configuration).findOnePermit(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {Permit} permit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermitApi
     */
    public updatePermit(id: string, permit: Permit, options?: any) {
        return PermitApiFp(this.configuration).updatePermit(id, permit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PermitTypeApi - axios parameter creator
 * @export
 */
export const PermitTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {PermitType} permitType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPermitType: async (permitType: PermitType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'permitType' is not null or undefined
            assertParamExists('createPermitType', 'permitType', permitType)
            const localVarPath = `/permitType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(permitType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermitType: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePermitType', 'id', id)
            const localVarPath = `/permitType/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllPermitType: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/permitType`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOnePermitType: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOnePermitType', 'id', id)
            const localVarPath = `/permitType/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {PermitType} permitType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermitType: async (id: string, permitType: PermitType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePermitType', 'id', id)
            // verify required parameter 'permitType' is not null or undefined
            assertParamExists('updatePermitType', 'permitType', permitType)
            const localVarPath = `/permitType/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(permitType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermitTypeApi - functional programming interface
 * @export
 */
export const PermitTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermitTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {PermitType} permitType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPermitType(permitType: PermitType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermitType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPermitType(permitType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePermitType(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePermitType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllPermitType(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PermitType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllPermitType(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOnePermitType(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermitType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOnePermitType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {PermitType} permitType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePermitType(id: string, permitType: PermitType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermitType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePermitType(id, permitType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PermitTypeApi - factory interface
 * @export
 */
export const PermitTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermitTypeApiFp(configuration)
    return {
        /**
         * 
         * @param {PermitType} permitType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPermitType(permitType: PermitType, options?: any): AxiosPromise<PermitType> {
            return localVarFp.createPermitType(permitType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePermitType(id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.deletePermitType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllPermitType(options?: any): AxiosPromise<Array<PermitType>> {
            return localVarFp.findAllPermitType(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOnePermitType(id: string, options?: any): AxiosPromise<PermitType> {
            return localVarFp.findOnePermitType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {PermitType} permitType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePermitType(id: string, permitType: PermitType, options?: any): AxiosPromise<PermitType> {
            return localVarFp.updatePermitType(id, permitType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PermitTypeApi - object-oriented interface
 * @export
 * @class PermitTypeApi
 * @extends {BaseAPI}
 */
export class PermitTypeApi extends BaseAPI {
    /**
     * 
     * @param {PermitType} permitType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermitTypeApi
     */
    public createPermitType(permitType: PermitType, options?: any) {
        return PermitTypeApiFp(this.configuration).createPermitType(permitType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermitTypeApi
     */
    public deletePermitType(id: string, options?: any) {
        return PermitTypeApiFp(this.configuration).deletePermitType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermitTypeApi
     */
    public findAllPermitType(options?: any) {
        return PermitTypeApiFp(this.configuration).findAllPermitType(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermitTypeApi
     */
    public findOnePermitType(id: string, options?: any) {
        return PermitTypeApiFp(this.configuration).findOnePermitType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {PermitType} permitType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermitTypeApi
     */
    public updatePermitType(id: string, permitType: PermitType, options?: any) {
        return PermitTypeApiFp(this.configuration).updatePermitType(id, permitType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlanApi - axios parameter creator
 * @export
 */
export const PlanApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllPlan: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/plan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOnePlan: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOnePlan', 'id', id)
            const localVarPath = `/plan/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlanApi - functional programming interface
 * @export
 */
export const PlanApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlanApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllPlan(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Plan>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllPlan(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOnePlan(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOnePlan(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlanApi - factory interface
 * @export
 */
export const PlanApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlanApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllPlan(options?: any): AxiosPromise<Array<Plan>> {
            return localVarFp.findAllPlan(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOnePlan(id: string, options?: any): AxiosPromise<Plan> {
            return localVarFp.findOnePlan(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlanApi - object-oriented interface
 * @export
 * @class PlanApi
 * @extends {BaseAPI}
 */
export class PlanApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanApi
     */
    public findAllPlan(options?: any) {
        return PlanApiFp(this.configuration).findAllPlan(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlanApi
     */
    public findOnePlan(id: string, options?: any) {
        return PlanApiFp(this.configuration).findOnePlan(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PropertyApi - axios parameter creator
 * @export
 */
export const PropertyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Property} property 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProperty: async (property: Property, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'property' is not null or undefined
            assertParamExists('createProperty', 'property', property)
            const localVarPath = `/property`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(property, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProperty: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProperty', 'id', id)
            const localVarPath = `/property/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllProperty: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/property`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneProperty: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOneProperty', 'id', id)
            const localVarPath = `/property/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Property} property 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProperty: async (id: string, property: Property, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProperty', 'id', id)
            // verify required parameter 'property' is not null or undefined
            assertParamExists('updateProperty', 'property', property)
            const localVarPath = `/property/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(property, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyApi - functional programming interface
 * @export
 */
export const PropertyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Property} property 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProperty(property: Property, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProperty(property, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProperty(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProperty(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllProperty(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Property>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllProperty(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOneProperty(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOneProperty(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Property} property 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProperty(id: string, property: Property, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProperty(id, property, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PropertyApi - factory interface
 * @export
 */
export const PropertyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyApiFp(configuration)
    return {
        /**
         * 
         * @param {Property} property 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProperty(property: Property, options?: any): AxiosPromise<Property> {
            return localVarFp.createProperty(property, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProperty(id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.deleteProperty(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllProperty(options?: any): AxiosPromise<Array<Property>> {
            return localVarFp.findAllProperty(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneProperty(id: string, options?: any): AxiosPromise<Property> {
            return localVarFp.findOneProperty(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Property} property 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProperty(id: string, property: Property, options?: any): AxiosPromise<Message> {
            return localVarFp.updateProperty(id, property, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertyApi - object-oriented interface
 * @export
 * @class PropertyApi
 * @extends {BaseAPI}
 */
export class PropertyApi extends BaseAPI {
    /**
     * 
     * @param {Property} property 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyApi
     */
    public createProperty(property: Property, options?: any) {
        return PropertyApiFp(this.configuration).createProperty(property, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyApi
     */
    public deleteProperty(id: string, options?: any) {
        return PropertyApiFp(this.configuration).deleteProperty(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyApi
     */
    public findAllProperty(options?: any) {
        return PropertyApiFp(this.configuration).findAllProperty(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyApi
     */
    public findOneProperty(id: string, options?: any) {
        return PropertyApiFp(this.configuration).findOneProperty(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {Property} property 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyApi
     */
    public updateProperty(id: string, property: Property, options?: any) {
        return PropertyApiFp(this.configuration).updateProperty(id, property, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StripeApi - axios parameter creator
 * @export
 */
export const StripeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession: async (uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/create-checkout-session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uNKNOWNBASETYPE, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeApi - functional programming interface
 * @export
 */
export const StripeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckoutSession(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckoutSession(uNKNOWNBASETYPE, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StripeApi - factory interface
 * @export
 */
export const StripeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeApiFp(configuration)
    return {
        /**
         * 
         * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any): AxiosPromise<object> {
            return localVarFp.createCheckoutSession(uNKNOWNBASETYPE, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export class StripeApi extends BaseAPI {
    /**
     * 
     * @param {UNKNOWN_BASE_TYPE} [uNKNOWNBASETYPE] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public createCheckoutSession(uNKNOWNBASETYPE?: UNKNOWN_BASE_TYPE, options?: any) {
        return StripeApiFp(this.configuration).createCheckoutSession(uNKNOWNBASETYPE, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TenantApi - axios parameter creator
 * @export
 */
export const TenantApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Tenant} tenant 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenant: async (tenant: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('createTenant', 'tenant', tenant)
            const localVarPath = `/tenant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tenant, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenant: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTenant', 'id', id)
            const localVarPath = `/tenant/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {string} [propertyId] Unique identifier for a property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllTenants: async (size: number, page: number, propertyId?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'size' is not null or undefined
            assertParamExists('findAllTenants', 'size', size)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('findAllTenants', 'page', page)
            const localVarPath = `/tenant`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (propertyId !== undefined) {
                localVarQueryParameter['propertyId'] = propertyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneTenant: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findOneTenant', 'id', id)
            const localVarPath = `/tenant/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Tenant} tenant 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenant: async (id: string, tenant: Tenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTenant', 'id', id)
            // verify required parameter 'tenant' is not null or undefined
            assertParamExists('updateTenant', 'tenant', tenant)
            const localVarPath = `/tenant/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tenant, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantApi - functional programming interface
 * @export
 */
export const TenantApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TenantApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Tenant} tenant 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTenant(tenant: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTenant(tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTenant(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTenant(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {string} [propertyId] Unique identifier for a property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllTenants(size: number, page: number, propertyId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TenantPage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllTenants(size, page, propertyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findOneTenant(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findOneTenant(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Tenant} tenant 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTenant(id: string, tenant: Tenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTenant(id, tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TenantApi - factory interface
 * @export
 */
export const TenantApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TenantApiFp(configuration)
    return {
        /**
         * 
         * @param {Tenant} tenant 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenant(tenant: Tenant, options?: any): AxiosPromise<Tenant> {
            return localVarFp.createTenant(tenant, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTenant(id: string, options?: any): AxiosPromise<Message> {
            return localVarFp.deleteTenant(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} size 
         * @param {number} page 
         * @param {string} [propertyId] Unique identifier for a property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllTenants(size: number, page: number, propertyId?: string, options?: any): AxiosPromise<Array<TenantPage>> {
            return localVarFp.findAllTenants(size, page, propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOneTenant(id: string, options?: any): AxiosPromise<Tenant> {
            return localVarFp.findOneTenant(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Unique identifier
         * @param {Tenant} tenant 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTenant(id: string, tenant: Tenant, options?: any): AxiosPromise<Tenant> {
            return localVarFp.updateTenant(id, tenant, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TenantApi - object-oriented interface
 * @export
 * @class TenantApi
 * @extends {BaseAPI}
 */
export class TenantApi extends BaseAPI {
    /**
     * 
     * @param {Tenant} tenant 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public createTenant(tenant: Tenant, options?: any) {
        return TenantApiFp(this.configuration).createTenant(tenant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public deleteTenant(id: string, options?: any) {
        return TenantApiFp(this.configuration).deleteTenant(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} size 
     * @param {number} page 
     * @param {string} [propertyId] Unique identifier for a property
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public findAllTenants(size: number, page: number, propertyId?: string, options?: any) {
        return TenantApiFp(this.configuration).findAllTenants(size, page, propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public findOneTenant(id: string, options?: any) {
        return TenantApiFp(this.configuration).findOneTenant(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Unique identifier
     * @param {Tenant} tenant 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    public updateTenant(id: string, tenant: Tenant, options?: any) {
        return TenantApiFp(this.configuration).updateTenant(id, tenant, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appVersion: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createUser', 'user', user)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Authorization required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication Id required
            await setApiKeyToObject(localVarHeaderParameter, "Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllUsers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appVersion(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllUsers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appVersion(options?: any): AxiosPromise<object> {
            return localVarFp.appVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user: User, options?: any): AxiosPromise<User> {
            return localVarFp.createUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllUsers(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.findAllUsers(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public appVersion(options?: any) {
        return UserApiFp(this.configuration).appVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(user: User, options?: any) {
        return UserApiFp(this.configuration).createUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public findAllUsers(options?: any) {
        return UserApiFp(this.configuration).findAllUsers(options).then((request) => request(this.axios, this.basePath));
    }
}


